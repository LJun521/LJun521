package main;

import java.io.*;  
import java.nio.file.Files;  
import java.nio.file.Paths;  
import java.util.*;  
  
public class PaperPlagiarismChecker {  
  
    public static void main(String[] args) {  
        if (args.length != 3) {  
            System.out.println("Usage: java PaperPlagiarismChecker <originalFilePath> <copiedFilePath> <outputFilePath>");  
            return;  
        }  
  
        String originalFilePath = args[0];  
        String copiedFilePath = args[1];  
        String outputFilePath = args[2];  
  
        try {  
            String originalText = readFile(originalFilePath);  
            String copiedText = readFile(copiedFilePath);  
  
            double similarity = calculateSimilarity(originalText, copiedText);  
  
            writeSimilarityToFile(outputFilePath, similarity);  
  
            System.out.println("Similarity (Plagiarism Rate): " + String.format("%.2f%%", similarity * 100));  
  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
    }  
  
    private static String readFile(String filePath) throws IOException {  
        return new String(Files.readAllBytes(Paths.get(filePath)));  
    }  
  
    private static double calculateSimilarity(String originalText, String copiedText) {  
        // Normalize text (remove punctuation, convert to lowercase, etc.)  
        String normalizedOriginal = normalizeText(originalText);  
        String normalizedCopied = normalizeText(copiedText);  
  
        // Split text into words  
        String[] originalWords = normalizedOriginal.split("\\s+");  
        String[] copiedWords = normalizedCopied.split("\\s+");  
  
        // Count word frequencies  
        Map<String, Integer> originalFreq = new HashMap<>();  
        Map<String, Integer> copiedFreq = new HashMap<>();  
  
        for (String word : originalWords) {  
            originalFreq.put(word, originalFreq.getOrDefault(word, 0) + 1);  
        }  
  
        for (String word : copiedWords) {  
            copiedFreq.put(word, copiedFreq.getOrDefault(word, 0) + 1);  
        }  
  
        // Calculate intersection of word frequencies  
        int intersectionCount = 0;  
        for (Map.Entry<String, Integer> entry : originalFreq.entrySet()) {  
            String word = entry.getKey();  
            int originalCount = entry.getValue();  
            int copiedCount = copiedFreq.getOrDefault(word, 0);  
            intersectionCount += Math.min(originalCount, copiedCount);  
        }  
  
        // Calculate total word count (considering duplicates)  
        int totalWordsOriginal = originalWords.length;  
        int totalWordsCopied = copiedWords.length;  
  
        // Adjust total words for similarity calculation (prevent division by zero)  
        int totalWords = Math.max(totalWordsOriginal, totalWordsCopied);  
  
        // Calculate similarity (cosine similarity-like approach)  
        // Note: This is not strictly cosine similarity but a simplified version  
        if (totalWords == 0) return 0.0;  
  
        return (double) intersectionCount / totalWords;  
  
        // Alternatively, you could use Jaccard similarity:  
        // return (double) intersectionCount / (originalWords.length + copiedWords.length - intersectionCount);  
    }  
  
    private static String normalizeText(String text) {  
        // Remove punctuation, convert to lowercase, etc.  
        // This is a very basic normalization, you might need a more sophisticated one  
        return text.replaceAll("[^a-zA-Z0-9\\s]", "").toLowerCase();  
    }  
  
    private static void writeSimilarityToFile(String filePath, double similarity) throws IOException {  
        try (BufferedWriter bw = Files.newBufferedWriter(Paths.get(filePath))) {  
            bw.write(String.format("%.2f", similarity));  
        }  
    }  
}
